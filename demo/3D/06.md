顶点着色器中，我们实现了漫反射光颜色的计算，使用的是：

<漫反射光颜色> = <入射光颜色> x <表面基底色> x (<光线方向> · <法线方向>)

计算漫反射光颜色需要：（1）入射光颜色 （2）表面基底色 （3）入射光方向 （4）表面法线方向。其中后两者都必须是归一化的（即长度为1.0）。

在上面的案例代码中：

a_Color 变量表示表面基底色

a_Normal变量表示表面法线方向

u_LightColor变量表示入射光颜色

u_LightDirection变量表示入射光方向（是在世界坐标系下的，在javascript中归一化了，可以避免着色器每次执行都对它进行归一化）

相关的变量已经获取，下面是进行处理：

着色器部分处理：

首先对a_Normal法线变量进行归一化，虽然写的值是已经归一化过的，但是顶点着色器可不知道传入的矢量是否经过了归一化，而且这里没有节省开销的理由（法向量是逐顶点的），由于使用x，y和z三个分量就可以表示法线方向，我们需要将这三个分量提取出来，使用到了vec3()方法，然后使用内置函数normalize()函数进行归一化。

接下来，我们计算点积<光线方向> · <法线方向>。法线方向已经被归一化，光线方向在传入进来之前已经被归一化。直接使用GLSL ES提供的内置函数dot()进行点积运算。然后又使用max()函数时因为如果计算出来的数大于90度的话，就已经在背面了。我们这是计算的不透明的，所以在背面就是0。

计算出来点积后，就可以继续套用公式进行漫反射光的颜色，计算出漫反射光的rgb颜色。

最后再把rgba的a给补上，最后就把颜色给计算了出来，再把颜色通过varying变量v_Color传到片元着色器。

js部分处理：

首先就给u_LightColor赋值了光线的颜色。

然后给u_LightDirection赋值光线方向，再使用cuon-matrix.js里面封装好的函数，直接在对象上调用一下，使对象的值归一化，最后把值赋值给了u_LightDirection。

最后在颜色下面声明了一个存储法向量的Float32Array将值存储，和顶点和颜色一起赋值。